{"version":3,"file":"reflective_provider.js","sourceRoot":"","sources":["../lib/reflective_provider.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\nimport { reflector } from './reflection/reflection';\nimport { Type } from './facade/type';\n\nimport { resolveForwardRef } from './forward_ref';\nimport { InjectionToken } from './injection_token';\nimport { Inject, Optional, Self, SkipSelf } from './metadata';\nimport { ClassProvider, ExistingProvider, FactoryProvider, Provider, TypeProvider, ValueProvider } from './provider';\nimport { invalidProviderError, mixingMultiProvidersWithRegularProvidersError, noAnnotationError } from './reflective_errors';\nimport { ReflectiveKey } from './reflective_key';\n\ninterface NormalizedProvider extends TypeProvider, ValueProvider, ClassProvider, ExistingProvider, FactoryProvider {}\n\n/**\n * `Dependency` is used by the framework to extend DI.\n * This is internal to Angular and should not be used directly.\n */\nexport class ReflectiveDependency {\n  constructor(public key: ReflectiveKey, public optional: boolean, public visibility: Self | SkipSelf | null) {}\n\n  static fromKey(key: ReflectiveKey): ReflectiveDependency {\n    return new ReflectiveDependency(key, false, null);\n  }\n}\n\nconst _EMPTY_LIST: any[] = [];\n\n/**\n * An internal resolved representation of a {@link Provider} used by the {@link Injector}.\n *\n * It is usually created automatically by `Injector.resolveAndCreate`.\n *\n * It can be created manually, as follows:\n *\n * ### Example ([live demo](http://plnkr.co/edit/RfEnhh8kUEI0G3qsnIeT?p%3Dpreview&p=preview))\n *\n * ```typescript\n * var resolvedProviders = Injector.resolve([{ provide: 'message', useValue: 'Hello' }]);\n * var injector = Injector.fromResolvedProviders(resolvedProviders);\n *\n * expect(injector.get('message')).toEqual('Hello');\n * ```\n *\n * @experimental\n */\nexport interface ResolvedReflectiveProvider {\n  /**\n   * A key, usually a `Type<any>`.\n   */\n  key: ReflectiveKey;\n\n  /**\n   * Factory function which can return an instance of an object represented by a key.\n   */\n  resolvedFactories: ResolvedReflectiveFactory[];\n\n  /**\n   * Indicates if the provider is a multi-provider or a regular provider.\n   */\n  multiProvider: boolean;\n}\n\n// tslint:disable-next-line:class-name\nexport class ResolvedReflectiveProvider_ implements ResolvedReflectiveProvider {\n  constructor(public key: ReflectiveKey, public resolvedFactories: ResolvedReflectiveFactory[], public multiProvider: boolean) {}\n\n  get resolvedFactory(): ResolvedReflectiveFactory {\n    return this.resolvedFactories[0];\n  }\n}\n\n/**\n * An internal resolved representation of a factory function created by resolving {@link\n * Provider}.\n * @experimental\n */\nexport class ResolvedReflectiveFactory {\n  constructor(\n    /**\n     * Factory function which can return an instance of an object represented by a key.\n     */\n    public factory: Function,\n    /**\n     * Arguments (dependencies) to the `factory` function.\n     */\n    public dependencies: ReflectiveDependency[]\n  ) {}\n}\n\n/**\n * Resolve a single provider.\n */\nfunction resolveReflectiveFactory(provider: NormalizedProvider): ResolvedReflectiveFactory {\n  let factoryFn: Function;\n  let resolvedDeps: ReflectiveDependency[];\n  if (provider.useClass) {\n    const useClass = resolveForwardRef(provider.useClass);\n    factoryFn = reflector.factory(useClass);\n    resolvedDeps = _dependenciesFor(useClass);\n  } else if (provider.useExisting) {\n    factoryFn = (aliasInstance: any) => aliasInstance;\n    resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];\n  } else if (provider.useFactory) {\n    factoryFn = provider.useFactory;\n    resolvedDeps = constructDependencies(provider.useFactory, provider.deps);\n  } else {\n    factoryFn = () => provider.useValue;\n    resolvedDeps = _EMPTY_LIST;\n  }\n  return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);\n}\n\n/**\n * Converts the {@link Provider} into {@link ResolvedProvider}.\n *\n * {@link Injector} internally only uses {@link ResolvedProvider}, {@link Provider} contains\n * convenience provider syntax.\n */\nfunction resolveReflectiveProvider(provider: NormalizedProvider): ResolvedReflectiveProvider {\n  return new ResolvedReflectiveProvider_(\n    ReflectiveKey.get(provider.provide),\n    [resolveReflectiveFactory(provider)],\n    provider.multi || false\n  );\n}\n\n/**\n * Resolve a list of Providers.\n */\nexport function resolveReflectiveProviders(providers: Provider[]): ResolvedReflectiveProvider[] {\n  const normalized = _normalizeProviders(providers, []);\n  const resolved = normalized.map(resolveReflectiveProvider);\n  const resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());\n  return Array.from(resolvedProviderMap.values());\n}\n\n/**\n * Merges a list of ResolvedProviders into a list where\n * each key is contained exactly once and multi providers\n * have been merged.\n */\nexport function mergeResolvedReflectiveProviders(\n  providers: ResolvedReflectiveProvider[],\n  normalizedProvidersMap: Map<number, ResolvedReflectiveProvider>\n): Map<number, ResolvedReflectiveProvider> {\n  for (let i = 0; i < providers.length; i++) {\n    const provider = providers[i];\n    const existing = normalizedProvidersMap.get(provider.key.id);\n    if (existing) {\n      if (provider.multiProvider !== existing.multiProvider) {\n        throw mixingMultiProvidersWithRegularProvidersError(existing, provider);\n      }\n      if (provider.multiProvider) {\n        for (let j = 0; j < provider.resolvedFactories.length; j++) {\n          existing.resolvedFactories.push(provider.resolvedFactories[j]);\n        }\n      } else {\n        normalizedProvidersMap.set(provider.key.id, provider);\n      }\n    } else {\n      let resolvedProvider: ResolvedReflectiveProvider;\n      if (provider.multiProvider) {\n        resolvedProvider = new ResolvedReflectiveProvider_(provider.key, provider.resolvedFactories.slice(), provider.multiProvider);\n      } else {\n        resolvedProvider = provider;\n      }\n      normalizedProvidersMap.set(provider.key.id, resolvedProvider);\n    }\n  }\n  return normalizedProvidersMap;\n}\n\nfunction _normalizeProviders(providers: Provider[], res: Provider[]): NormalizedProvider[] {\n  providers.forEach(b => {\n    if (b instanceof Type) {\n      res.push({ provide: b, useClass: b });\n    } else if (b && typeof b === 'object' && (b as any).provide !== undefined) {\n      res.push(b as NormalizedProvider);\n    } else if (b instanceof Array) {\n      _normalizeProviders(b as Provider[], res);\n    } else {\n      throw invalidProviderError(b);\n    }\n  });\n\n  return res as NormalizedProvider[];\n}\n\nexport function constructDependencies(typeOrFunc: any, dependencies?: any[]): ReflectiveDependency[] {\n  if (!dependencies) {\n    return _dependenciesFor(typeOrFunc);\n  } else {\n    const params: any[][] = dependencies.map(t => [t]);\n    return dependencies.map(t => _extractToken(typeOrFunc, t, params));\n  }\n}\n\nfunction _dependenciesFor(typeOrFunc: any): ReflectiveDependency[] {\n  const params = reflector.parameters(typeOrFunc);\n\n  if (!params) return [];\n  if (params.some(p => p == null)) {\n    throw noAnnotationError(typeOrFunc, params);\n  }\n  return params.map(p => _extractToken(typeOrFunc, p, params));\n}\n\nfunction _extractToken(typeOrFunc: any, metadata: any[] | any, params: any[][]): ReflectiveDependency {\n  let token: any = null;\n  let optional = false;\n\n  if (!Array.isArray(metadata)) {\n    if (metadata instanceof Inject) {\n      return _createDependency(metadata['token'], optional, null);\n    } else {\n      return _createDependency(metadata, optional, null);\n    }\n  }\n\n  let visibility: Self | SkipSelf | null = null;\n\n  for (let i = 0; i < metadata.length; ++i) {\n    const paramMetadata = metadata[i];\n\n    if (paramMetadata instanceof Type) {\n      token = paramMetadata;\n    } else if (paramMetadata instanceof Inject) {\n      token = paramMetadata['token'];\n    } else if (paramMetadata instanceof Optional) {\n      optional = true;\n    } else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {\n      visibility = paramMetadata;\n    } else if (paramMetadata instanceof InjectionToken) {\n      token = paramMetadata;\n    }\n  }\n\n  token = resolveForwardRef(token);\n\n  if (token != null) {\n    return _createDependency(token, optional, visibility);\n  } else {\n    throw noAnnotationError(typeOrFunc, params);\n  }\n}\n\nfunction _createDependency(token: any, optional: boolean, visibility: Self | SkipSelf | null): ReflectiveDependency {\n  return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);\n}\n"]}