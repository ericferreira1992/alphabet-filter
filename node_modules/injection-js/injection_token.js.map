{"version":3,"file":"injection_token.js","sourceRoot":"","sources":["../lib/injection_token.ts"],"names":[],"mappings":"AAAA;;;;;;GAMG;;AAEH;;;;;;;;;;;;;;;;;;;;;;GAsBG;AACH;IACE,qBAAsB,KAAa;QAAb,UAAK,GAAL,KAAK,CAAQ;IAAG,CAAC;IAEvC,8BAAQ,GAAR;QACE,OAAO,WAAS,IAAI,CAAC,KAAO,CAAC;IAC/B,CAAC;IACH,kBAAC;AAAD,CAAC,AAND,IAMC;;AAED;;;;;;;;;;;;;;;;;;;;;GAqBG;AACH;IAAuC,0CAAW;IAIhD,wBAAY,IAAY;eACtB,kBAAM,IAAI,CAAC;IACb,CAAC;IAED,iCAAQ,GAAR;QACE,OAAO,oBAAkB,IAAI,CAAC,KAAO,CAAC;IACxC,CAAC;IACH,qBAAC;AAAD,CAAC,AAXD,CAAuC,WAAW,GAWjD","sourcesContent":["/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n/**\n * Creates a token that can be used in a DI Provider.\n *\n * ### Example ([live demo](http://plnkr.co/edit/Ys9ezXpj2Mnoy3Uc8KBp?p=preview))\n *\n * ```typescript\n * var t = new OpaqueToken(\"value\");\n *\n * var injector = Injector.resolveAndCreate([\n *   {provide: t, useValue: \"bindingValue\"}\n * ]);\n *\n * expect(injector.get(t)).toEqual(\"bindingValue\");\n * ```\n *\n * Using an `OpaqueToken` is preferable to using strings as tokens because of possible collisions\n * caused by multiple providers using the same string as two different tokens.\n *\n * Using an `OpaqueToken` is preferable to using an `Object` as tokens because it provides better\n * error messages.\n * @deprecated since v4.0.0 because it does not support type information, use `InjectionToken<?>`\n * instead.\n */\nexport class OpaqueToken {\n  constructor(protected _desc: string) {}\n\n  toString(): string {\n    return `Token ${this._desc}`;\n  }\n}\n\n/**\n * Creates a token that can be used in a DI Provider.\n *\n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parametrized type.\n *\n * `InjectionToken` is parameterized on `T` which is the type of object which will be returned by\n * the `Injector`. This provides additional level of type safety.\n *\n * ```\n * interface MyInterface {...}\n * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\n * // myInterface is inferred to be MyInterface.\n * ```\n *\n * ### Example\n *\n * {@example core/di/ts/injector_spec.ts region='InjectionToken'}\n *\n * @stable\n */\nexport class InjectionToken<T> extends OpaqueToken {\n  // This unused property is needed here so that TS can differentiate InjectionToken from\n  // OpaqueToken since otherwise they would have the same shape and be treated as equivalent.\n  private _differentiate_from_OpaqueToken_structurally: any;\n  constructor(desc: string) {\n    super(desc);\n  }\n\n  toString(): string {\n    return `InjectionToken ${this._desc}`;\n  }\n}\n"]}