{"version":3,"file":"analyse-sources.transform.js","sourceRoot":"","sources":["../../../../src/lib/ng-package/entry-point/analyse-sources.transform.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript';\nimport { pipe } from 'rxjs';\nimport { map } from 'rxjs/operators';\nimport { isEntryPoint, EntryPointNode, isPackage, PackageNode } from '../nodes';\nimport { cacheCompilerHost } from '../../ts/cache-compiler-host';\nimport { BuildGraph } from '../../graph/build-graph';\nimport { Transform } from '../../graph/transform';\nimport { debug } from '../../utils/log';\nimport { ensureUnixPath } from '../../utils/path';\n\nexport const analyseSourcesTransform: Transform = pipe(\n  map(graph => {\n    const entryPoints = graph.filter(isEntryPoint) as EntryPointNode[];\n    const dirtyEntryPoints = entryPoints.filter(x => x.state !== 'done') as EntryPointNode[];\n\n    for (const entryPoint of dirtyEntryPoints) {\n      analyseEntryPoint(graph, entryPoint, entryPoints);\n    }\n\n    return graph;\n  }),\n);\n\n/**\n * Analyses an entrypoint, searching for TypeScript dependencies and additional resources (Templates and Stylesheets).\n *\n * @param graph Build graph\n * @param entryPoint Current entry point that should be analysed.\n * @param entryPoints List of all entry points.\n */\nfunction analyseEntryPoint(graph: BuildGraph, entryPoint: EntryPointNode, entryPoints: EntryPointNode[]) {\n  const { oldPrograms, analysesSourcesFileCache, moduleResolutionCache } = entryPoint.cache;\n  const oldProgram = oldPrograms && (oldPrograms['analysis'] as ts.Program | undefined);\n  const { moduleId } = entryPoint.data.entryPoint;\n  const packageNode = graph.find(isPackage) as PackageNode;\n  const primaryModuleId = packageNode.data.primary.moduleId;\n\n  debug(`Analysing sources for ${moduleId}`);\n  const tsConfigOptions: ts.CompilerOptions = {\n    ...entryPoint.data.tsConfig.options,\n    skipLibCheck: true,\n    noLib: true,\n    types: [],\n  };\n\n  const compilerHost = cacheCompilerHost(\n    graph,\n    entryPoint,\n    tsConfigOptions,\n    moduleResolutionCache,\n    undefined,\n    analysesSourcesFileCache,\n    false,\n  );\n\n  compilerHost.resolveModuleNames = (moduleNames: string[], containingFile: string) => {\n    return moduleNames.map(moduleName => {\n      if (!moduleName.startsWith('.')) {\n        return undefined;\n      }\n\n      const { resolvedModule } = ts.resolveModuleName(\n        moduleName,\n        ensureUnixPath(containingFile),\n        tsConfigOptions,\n        compilerHost,\n        moduleResolutionCache,\n      );\n\n      return resolvedModule;\n    });\n  };\n\n  const program: ts.Program = ts.createProgram(\n    entryPoint.data.tsConfig.rootNames,\n    tsConfigOptions,\n    compilerHost,\n    oldProgram,\n  );\n\n  // this is a workaround due to the below\n  // https://github.com/angular/angular/issues/24010\n  const potentialDependencies = new Set<string>();\n  program\n    .getSourceFiles()\n    .filter(x => !x.fileName.endsWith('.d.ts'))\n    .forEach(sourceFile => {\n      sourceFile.statements\n        .filter(x => ts.isImportDeclaration(x) || ts.isExportDeclaration(x))\n        .forEach((node: ts.ImportDeclaration | ts.ExportDeclaration) => {\n          const { moduleSpecifier } = node;\n          if (!moduleSpecifier || !ts.isStringLiteral(moduleSpecifier)) {\n            return;\n          }\n\n          const moduleName = moduleSpecifier.text;\n          if (moduleName === primaryModuleId || moduleName.startsWith(`${primaryModuleId}/`)) {\n            potentialDependencies.add(moduleName);\n          }\n        });\n    });\n\n  debug(`tsc program structure is reused: ${oldProgram ? (oldProgram as any).structureIsReused : 'No old program'}`);\n\n  entryPoint.cache.oldPrograms = { ...entryPoint.cache.oldPrograms, ['analysis']: program };\n\n  const entryPointsMapped: Record<string, EntryPointNode> = {};\n  for (const dep of entryPoints) {\n    entryPointsMapped[dep.data.entryPoint.moduleId] = dep;\n  }\n\n  for (const moduleName of potentialDependencies) {\n    const dep = entryPointsMapped[moduleName];\n\n    if (dep) {\n      debug(`Found entry point dependency: ${moduleId} -> ${moduleName}`);\n\n      if (moduleId === moduleName) {\n        throw new Error(`Entry point ${moduleName} has a circular dependency on itself.`);\n      }\n\n      if (dep.some(n => entryPoint === n)) {\n        throw new Error(`Entry point ${moduleName} has a circular dependency on ${moduleId}.`);\n      }\n\n      entryPoint.dependsOn(dep);\n    } else {\n      throw new Error(`Entry point ${moduleName} which is required by ${moduleId} doesn't exists.`);\n    }\n  }\n}\n"]}