{"version":3,"file":"depth.js","sourceRoot":"","sources":["../../../src/lib/graph/depth.ts"],"names":[],"mappings":"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","sourcesContent":["export type Token = string;\nexport type Depth = number;\n\n/**\n * Groups of tokens. The index is the depth value. The array value is a group of tokens.\n */\nexport type Groups = Token[][];\n\n/**\n * DepthBuilder calculates depth values for nodes and dependencies.\n *\n * Depth represents the furthest distance (number of edges) from a node w/o dependencies.\n * A depth of zero indicates that a node has no dependency.\n * Lower depth values indicate that a node need to be built prior to nodes with a higher depth.\n * Nodes with the same depth value may be built in parallel.\n *\n * #### Example\n *\n * A simple example:\n *\n *  - foo depends on bar\n *  - foo depends on foobar\n *  - bar depends on foobar\n *\n * Here, foobar has depth 0, bar has depth 1, and foo has depth 2.\n *\n * @link https://github.com/ng-packagr/ng-packagr/pull/419#issuecomment-354015908\n */\nexport class DepthBuilder {\n  // this serves as a tracker for dependencies between tokens\n  private dependencyMap = new Map<Token, Token[]>();\n\n  public add(node: Token, dependencies: Token[] | Token = []) {\n    // Normalize to array\n    dependencies = dependencies instanceof Array ? dependencies : [dependencies];\n\n    if (this.dependencyMap.has(node)) {\n      // Add to existing and de-duplicate\n      const existing = this.dependencyMap.get(node);\n      const deps = existing.concat(dependencies).filter((value, index, self) => {\n        return self.indexOf(value) === index;\n      });\n      this.dependencyMap.set(node, deps);\n    } else {\n      this.dependencyMap.set(node, dependencies);\n    }\n\n    if (dependencies) {\n      for (const dependency of dependencies) {\n        if (!this.dependencyMap.has(dependency)) {\n          this.dependencyMap.set(dependency, []);\n        }\n      }\n    }\n  }\n\n  public build(): Groups {\n    const allNodes = Array.from(this.dependencyMap.entries()).map(([token, dependencies]) => ({\n      token,\n      dependencies,\n    }));\n    // Start with root nodes and expand from there\n    const nodeQueue = allNodes.filter(node => node.dependencies.length === 0);\n\n    // Serves as a tracker for what nodes have been processed, and their furthest distance from a root node\n    const nodeDepths = new Map<Token, Depth>();\n    for (const node of nodeQueue) {\n      nodeDepths.set(node.token, 0);\n    }\n\n    // We will use this later to reduce the frequency of dynamic memory allocations\n    let maxDepth = 0;\n\n    // Walk the tree to determine longest path from root for each node\n    while (nodeQueue.length > 0) {\n      const currentNode = nodeQueue.pop();\n      const currentDepth = nodeDepths.get(currentNode.token) + 1;\n      if (currentDepth > maxDepth) {\n        maxDepth = currentDepth;\n      }\n\n      const parentNodes = allNodes.filter(node => node.dependencies.find(dep => dep === currentNode.token));\n      parentNodes.forEach(parent => {\n        if (!nodeDepths.has(parent.token)) {\n          // Push the dependency to the queue and track its depth\n          nodeQueue.push(parent);\n          nodeDepths.set(parent.token, currentDepth);\n        }\n\n        const dependencyDepth = nodeDepths.get(parent.token);\n        if (currentDepth > dependencyDepth) {\n          // Push the dependency to the queue again and track its depth\n          nodeQueue.push(parent);\n          nodeDepths.set(parent.token, currentDepth);\n        }\n      });\n    }\n\n    // All nodes with the same max distance from a root can be run in parallel\n    // Now we need to bucket nodes by max depth\n    const buckets: Token[][] = new Array<Token[]>(maxDepth + 1);\n    for (let i = 0; i < buckets.length; i++) {\n      buckets[i] = [];\n    }\n\n    nodeDepths.forEach((depth, node) => {\n      buckets[depth].push(node);\n    });\n\n    return buckets;\n  }\n}\n"]}