{"version":3,"file":"node.js","sourceRoot":"","sources":["../../../src/lib/graph/node.ts"],"names":[],"mappings":";;;AAEa,QAAA,WAAW,GAAc,OAAO,CAAC;AACjC,QAAA,gBAAgB,GAAc,aAAa,CAAC;AAC5C,QAAA,aAAa,GAAc,SAAS,CAAC;AACrC,QAAA,UAAU,GAAc,MAAM,CAAC;AAE5C;;GAEG;AACH,MAAa,IAAI;IACf,YAA4B,GAAW;QAAX,QAAG,GAAH,GAAG,CAAQ;QAMhC,UAAK,GAAc,EAAE,CAAC;QAsBrB,gBAAW,GAAW,EAAE,CAAC;QACzB,eAAU,GAAW,EAAE,CAAC;IA7BU,CAAC;IAQpC,MAAM,CAAC,EAA2C;QACvD,OAAO,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;IACrC,CAAC;IAEM,IAAI,CAAC,EAA2C;QACrD,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACnC,CAAC;IAEM,IAAI,CAAC,EAA2C;QACrD,OAAO,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IACnC,CAAC;IAED,IAAW,UAAU;QACnB,OAAO,IAAI,CAAC,WAAW,CAAC;IAC1B,CAAC;IAED,IAAW,SAAS;QAClB,OAAO,IAAI,CAAC,UAAU,CAAC;IACzB,CAAC;IAKD,2IAA2I;IACpI,SAAS,CAAC,SAAwB;QACvC,MAAM,OAAO,GAAG,SAAS,YAAY,KAAK,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC;QAErE,KAAK,MAAM,MAAM,IAAI,OAAO,EAAE;YAC5B,IAAI,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,CAAC,GAAG,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE;gBACnD,sCAAsC;gBACtC,SAAS;aACV;YAED,MAAM,CAAC,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;YAC7B,IAAI,CAAC,WAAW,CAAC,IAAI,CAAC,MAAM,CAAC,CAAC;SAC/B;IACH,CAAC;CACF;AA9CD,oBA8CC","sourcesContent":["export type NodeState = '' | 'dirty' | 'in-progress' | 'pending' | 'done';\n\nexport const STATE_DIRTY: NodeState = 'dirty';\nexport const STATE_IN_PROGESS: NodeState = 'in-progress';\nexport const STATE_PENDING: NodeState = 'pending';\nexport const STATE_DONE: NodeState = 'done';\n\n/**\n * A Node in the {@link BuildGraph}.\n */\nexport class Node {\n  constructor(public readonly url: string) {}\n\n  public type: string;\n\n  public data: any;\n\n  public state: NodeState = '';\n\n  public filter(by: (value: Node, index: number) => boolean): Node[] {\n    return this._dependents.filter(by);\n  }\n\n  public find(by: (value: Node, index: number) => boolean): Node | undefined {\n    return this._dependents.find(by);\n  }\n\n  public some(by: (value: Node, index: number) => boolean): boolean {\n    return this._dependents.some(by);\n  }\n\n  public get dependents(): Node[] {\n    return this._dependents;\n  }\n\n  public get dependees(): Node[] {\n    return this._dependees;\n  }\n\n  private _dependents: Node[] = [];\n  private _dependees: Node[] = [];\n\n  /** @experimental DO NOT USE. For time being, dirty checking is for `type=entryPoint && state !== 'done'` (full rebuild of entry point). */\n  public dependsOn(dependent: Node | Node[]) {\n    const newDeps = dependent instanceof Array ? dependent : [dependent];\n\n    for (const newDep of newDeps) {\n      if (newDep._dependees.some(x => x.url === this.url)) {\n        // nodes already depends on each other\n        continue;\n      }\n\n      newDep._dependees.push(this);\n      this._dependents.push(newDep);\n    }\n  }\n}\n"]}